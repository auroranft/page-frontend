import{C as g,r as c,u as _,D as w,E as p,w as b,G as C,H as P}from"./entry-f37e1690.mjs";const x=r=>g(r)?r:c(r),O=()=>null;function B(r,i,a={}){var o,h,y,m,v;if(typeof r!="string")throw new TypeError("asyncData key must be a string");if(typeof i!="function")throw new TypeError("asyncData handler must be a function");a={server:!0,default:O,...a},a.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),a.lazy=(h=(o=a.lazy)!=null?o:a.defer)!=null?h:!1,a.initialCache=(y=a.initialCache)!=null?y:!0;const e=_(),f=C();if(f&&!f._nuxtOnBeforeMountCbs){const s=f._nuxtOnBeforeMountCbs=[];f&&(w(()=>{s.forEach(t=>{t()}),s.splice(0,s.length)}),p(()=>s.splice(0,s.length)))}const l=()=>a.initialCache&&e.payload.data[r]!==void 0,n={data:x((m=e.payload.data[r])!=null?m:a.default()),pending:c(!l()),error:c((v=e.payload._errors[r])!=null?v:null)};n.refresh=(s={})=>e._asyncDataPromises[r]?e._asyncDataPromises[r]:s._initial&&l()?e.payload.data[r]:(n.pending.value=!0,e._asyncDataPromises[r]=Promise.resolve(i(e)).then(t=>{a.transform&&(t=a.transform(t)),a.pick&&(t=R(t,a.pick)),n.data.value=t,n.error.value=null}).catch(t=>{n.error.value=t,n.data.value=P(a.default())}).finally(()=>{n.pending.value=!1,e.payload.data[r]=n.data.value,n.error.value&&(e.payload._errors[r]=!0),delete e._asyncDataPromises[r]}),e._asyncDataPromises[r]);const u=()=>n.refresh({_initial:!0}),D=a.server!==!1&&e.payload.serverRendered;{D&&e.isHydrating&&r in e.payload.data?n.pending.value=!1:f&&e.payload.serverRendered&&(e.isHydrating||a.lazy)?f._nuxtOnBeforeMountCbs.push(u):u(),a.watch&&b(a.watch,()=>n.refresh());const s=e.hook("app:data:refresh",t=>{if(!t||t.includes(r))return n.refresh()});f&&p(s)}const d=Promise.resolve(e._asyncDataPromises[r]).then(()=>n);return Object.assign(d,n),d}function R(r,i){const a={};for(const e of i)a[e]=r[e];return a}export{B as u};
